import dotenv from 'dotenv';
dotenv.config();

import { initDb } from './utils/db';
import feedbackService from './services/feedback.service';
import hybridService from './services/hybrid.service';
import multiHopService from './services/multihop.service';
import { v4 as uuidv4 } from 'uuid';

async function main() {
    console.log("Initializing DB...");
    initDb();

    // Give DB moment to init
    await new Promise(r => setTimeout(r, 1000));

    const TEST_QUERY = "What is the Spline Protocol?"; // Something ambiguous or imaginary

    // ---------------------------------------------------------
    // TEST 1: Baseline Search
    // ---------------------------------------------------------
    console.log("\n--- TEST 1: Baseline Search ---");
    // We use MultiHop to ensure everything is logged
    const result1 = await multiHopService.performMultiHopSearch(TEST_QUERY);

    if (result1.results.length === 0) {
        console.warn("No results found. Cannot proceed with feedback test effectively.");
        return; // Or maybe inject dummy data?
    }

    const topDoc = result1.results[0];
    const initialScore = topDoc.finalScore;
    console.log(`Top Doc: ${topDoc.id}`);
    console.log(`Initial Final Score: ${initialScore.toFixed(4)} (Feed: ${topDoc.feedbackScore.toFixed(4)})`);

    // ---------------------------------------------------------
    // TEST 2: Submit Negative Feedback
    // ---------------------------------------------------------
    console.log("\n--- TEST 2: Submit Negative Feedback ---");

    // We simulate a response cycle
    const responseId = uuidv4();
    const queryId = result1.queryId;

    // Log response
    await feedbackService.logResponse(responseId, queryId, "This is an incorrect answer generated by the LLM.");

    // Log Evidence Chain (CRITICAL for Failure Analysis)
    // We assume all hops contributed
    await feedbackService.logEvidenceChain(
        responseId,
        result1.hopIds,
        result1.results.map(r => r.id),
        0.8
    );

    // Submit Negative Feedback (-1)
    await feedbackService.submitFeedback(responseId, -1);
    console.log("Negative feedback (-1) submitted for Response", responseId);

    // Wait for async background processing (if any) - here it is awaited, but let's pause for effect/DB flush
    await new Promise(r => setTimeout(r, 500));

    // ---------------------------------------------------------
    // TEST 3: Verify Penalty (Score Drop)
    // ---------------------------------------------------------
    console.log("\n--- TEST 3: Verify Penalty ---");
    const result2 = await multiHopService.performMultiHopSearch(TEST_QUERY);
    const topDocAgain = result2.results.find(d => d.id === topDoc.id);

    if (topDocAgain) {
        console.log(`Doc (${topDoc.id}) Score After Feedback: ${topDocAgain.finalScore.toFixed(4)} (Feed: ${topDocAgain.feedbackScore.toFixed(4)})`);
        if (topDocAgain.finalScore < initialScore) {
            console.log("✅ SUCCESS: Score dropped.");
        } else {
            console.log("❌ FAILURE: Score did not drop. (Might need more feedback to move needle significantly)");
        }
    } else {
        console.log("✅ SUCCESS: Doc dropped out of top results entirely.");
    }

    // ---------------------------------------------------------
    // TEST 4: Correction Injection
    // ---------------------------------------------------------
    console.log("\n--- TEST 4: Correction Injection ---");
    const correctionText = "The Spline Protocol is a mechanism for interpolating curves in 3D space.";

    // Submit correction on the same bad response
    await feedbackService.submitFeedback(responseId, -1, correctionText);

    // Wait for embedding upsert
    await new Promise(r => setTimeout(r, 2000));

    console.log("Searching for the correction content...");
    // Search for a paraphrase
    const paraphrase = "How do we interpolate curves?";
    const result3 = await hybridService.performHybridSearch(paraphrase, 5);

    // Check if any result looks like our correction
    const correctionMatch = result3.find(r => r.metadata?.type === 'correction');

    if (correctionMatch) {
        console.log(`✅ SUCCESS: Found injected correction! ID: ${correctionMatch.id}`);
        console.log(`   Text: "${correctionMatch.metadata.text}"`);
    } else {
        console.log("⚠️ WARNING: Correction not found in top 5. Might need tuning or exact match.");
        // Debug: check top results
        console.log("Top results:", result3.map(r => r.id + " (" + (r.metadata?.type || 'doc') + ")"));
    }
}

main().catch(console.error);
